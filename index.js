// Generated by LiveScript 1.2.0
var mongodb, MongoClient, db, collection, config, _, async, request, Job, Queue, updateConfig, createJob, createBatch, args, queues, express, app, bodyParser, router, toString$ = {}.toString;
mongodb = require('mongodb');
MongoClient = mongodb.MongoClient;
db = collection = config = null;
_ = require('prelude-ls-extended');
async = require('async');
request = require('request');
Job = (function(){
  Job.displayName = 'Job';
  var prototype = Job.prototype, constructor = Job;
  function Job(model){
    this.model = model != null
      ? model
      : {};
    this.data = this.model.data;
    this.queue = queues[this.model.type];
  }
  prototype.option = function(it){
    var that;
    switch (false) {
    case (that = this.model[it]) == null:
      return that;
    default:
      return this.queue.options[it];
    }
  };
  prototype.update = function(data, next){
    import$(this.model, data);
    collection.update({
      _id: this.model._id
    }, {
      $set: data
    }, next);
  };
  prototype.setState = function(state, next){
    var updateData, backoff, backoffType, attempt, doc, this$ = this;
    next == null && (next = function(){});
    this.queue.processingCount -= 1;
    updateData = {};
    if (state === 'failed') {
      updateData.failedAttempts = (this.model.failedAttempts || 0) + 1;
      if (this.option('attempts') <= 0 || updateData.failedAttempts < this.option('attempts')) {
        state = 'pending';
        backoff = this.option('backoff');
        backoffType = toString$.call(backoff).slice(8, -1);
        if ((backoffType === 'Number' && backoff > 0) || backoffType === 'String') {
          state = 'delayed';
          attempt = updateData.failedAttempts;
          doc = this.model;
          updateData.delayTil = Date.now() + (backoffType === 'String' ? eval(backoff) : backoff) * 1000;
        }
      }
    }
    if (state === 'killed') {
      state = 'failed';
    }
    this.update((updateData.state = state, updateData), function(err){
      next(err);
    });
  };
  prototype.done = function(err){
    var this$ = this;
    err == null && (err = null);
    if (err == null) {
      this.setState('successful', function(err){
        this$.queue.processPendingJobs();
      });
    } else {
      this.setState('failed', function(err){
        this$.queue.processPendingJobs();
      });
    }
  };
  prototype.retry = function(next){
    next == null && (next = function(){});
    this.setState('pending', next);
  };
  prototype.kill = function(next){
    next == null && (next = function(){});
    this.setState('killed', next);
  };
  prototype.log = function(message, next){
    next == null && (next = function(){});
    collection.update({
      _id: this.model._id
    }, {
      $push: {
        logs: message
      }
    }, next);
  };
  return Job;
}());
Job.create = function(model, next){
  var delay, ref$, ref1$, duration, ref2$, ref3$;
  model.type == null && (model.type = 'default');
  model.state = 'pending';
  delay = model.delay || ((ref$ = queues[model.type]) != null ? (ref1$ = ref$.options) != null ? ref1$.delay : void 8 : void 8) || 0;
  if (delay > 0) {
    model.state = 'delayed';
    model.delayTil = Date.now() + delay * 1000;
  }
  duration = model.duration || ((ref2$ = queues[model.type]) != null ? (ref3$ = ref2$.options) != null ? ref3$.duration : void 8 : void 8) || 0;
  model.resetAt = Date.now() + duration * 1000;
  collection.insert(model, function(err, docs){
    var job;
    console.log('inserted new job');
    job = new Job(docs[0]);
    next(err, job);
  });
};
Queue = (function(){
  Queue.displayName = 'Queue';
  var prototype = Queue.prototype, constructor = Queue;
  function Queue(type, options){
    this.type = type;
    options == null && (options = {});
    this.updateConfig(options);
    this.processingCount = 0;
    this.processPendingJobs();
  }
  prototype.updateConfig = function(options){
    this.options = import$(import$({}, config.queues['default']), options);
  };
  prototype.processPendingJobs = function(){
    var this$ = this;
    console.log('processingCount:', this.type, this.processingCount);
    if (this.options.limit > 0 && this.processingCount >= this.options.limit) {
      return;
    }
    this.processingCount += 1;
    (function(next){
      if (this$.options.rateLimit > 0 && this$.options.rateInterval > 0) {
        collection.find({
          lastProcessed: {
            $gte: Date.now() - this$.options.rateInterval * 1000
          }
        }).count(function(err, count){
          if (count < this$.options.rateLimit) {
            next();
          } else {
            return this$.processingCount -= 1;
          }
        });
      } else {
        next();
      }
    })(function(){
      collection.findAndModify({
        type: this$.type,
        state: 'pending'
      }, [['priority', 'desc']], {
        $set: {
          state: 'processing',
          lastProcessed: Date.now()
        }
      }, {
        'new': true
      }, function(err, doc){
        var job;
        job = doc ? new Job(doc) : null;
        if (!job) {
          return this$.processingCount -= 1;
        }
        this$.process(job);
        this$.processPendingJobs();
      });
    });
  };
  prototype.process = function(job){
    console.log('pushing job to:', job.option('url'));
    request({
      url: job.option('url'),
      method: job.option('method'),
      json: job.model
    }, function(err, res, body){
      var message;
      console.log('Done!');
      if (err) {
        return job.done(err);
      }
      if (res.statusCode === 200) {
        job.done(null, body);
      } else if (res.statusCode === 202) {
        job.retry();
      } else if (res.statusCode === 403) {
        job.kill();
      } else {
        message = res.statusCode + (body ? ": " + body : '');
        job.done(message);
      }
    });
  };
  return Queue;
}());
updateConfig = function(){
  db.collection('config').findOne(function(err, _config){
    var k, ref$, v, that;
    config = _config;
    if (config == null) {
      config = {
        queues: {
          'default': {
            priority: 0,
            limit: 0,
            rateLimit: 0,
            rateInterval: 0,
            attempts: 1,
            backoff: 0,
            delay: 0,
            duration: 60 * 60,
            url: null,
            method: 'POST'
          }
        }
      };
      db.collection('config').insert(config, function(err, docs){});
    }
    for (k in ref$ = config.queues) {
      v = ref$[k];
      if ((that = queues[k]) != null) {
        that.updateConfig(v);
      } else {
        queues[k] = new Queue(k, v);
      }
    }
  });
};
createJob = function(obj, next){
  next == null && (next = function(){});
  Job.create(obj, function(err, job){
    var ref$;
    if (job.model.state === 'pending') {
      if ((ref$ = job.queue) != null) {
        ref$.processPendingJobs();
      }
    }
    next(err);
  });
};
createBatch = function(arr, next){
  next == null && (next = function(){});
  async.each(arr, function(){
    Job.create.apply(this, arguments);
  }, next);
};
args = {
  connect: process.argv[2] || 'mongodb://farzher:testing@kahana.mongohq.com:10017/queue',
  port: process.argv[3] || 5672,
  promoteInterval: 5000
};
queues = {};
MongoClient.connect(args.connect, function(err, _db){
  console.log('Connected');
  db = _db;
  collection = db.collection('jobs');
  updateConfig();
  collection.ensureIndex({
    type: 1
  }, function(){
    collection.ensureIndex({
      state: 1
    }, function(){
      collection.ensureIndex({
        priority: 1
      }, function(){
        collection.ensureIndex({
          delayTil: 1
        }, function(){
          collection.ensureIndex({
            resetAt: 1
          }, function(){
            setInterval(function(){
              var processed, i$, ref$, queue;
              processed = [];
              for (i$ in ref$ = queues) {
                queue = ref$[i$];
                if (queue.options.rateLimit > 0 && queue.options.rateInterval > 0) {
                  processed.push(queue.type);
                  queue.processPendingJobs();
                }
              }
              collection.find({
                state: 'delayed',
                delayTil: {
                  $lte: Date.now()
                }
              }, {
                _id: true,
                type: true
              }).toArray(function(err, delayedDocs){
                collection.find({
                  state: 'processing',
                  resetAt: {
                    $lte: Date.now()
                  }
                }, {
                  _id: true,
                  type: true
                }).toArray(function(err, hangingDocs){
                  var docs, _ids;
                  docs = delayedDocs.concat(hangingDocs);
                  if (_.empty(docs)) {
                    return;
                  }
                  _ids = _.map(function(it){
                    return it._id;
                  }, docs);
                  collection.update({
                    _id: {
                      $in: _ids
                    }
                  }, {
                    $set: {
                      state: 'pending'
                    }
                  }, {
                    multi: true
                  }, function(err){
                    var i$, ref$, len$, type, ref1$;
                    for (i$ = 0, len$ = (ref$ = _.unique(_.reject((fn$), _.map(fn1$, docs)))).length; i$ < len$; ++i$) {
                      type = ref$[i$];
                      if ((ref1$ = queues[type]) != null) {
                        ref1$.processPendingJobs();
                      }
                    }
                    function fn$(it){
                      return in$(it, processed);
                    }
                    function fn1$(it){
                      return it.type;
                    }
                  });
                });
              });
            }, args.promoteInterval);
          });
        });
      });
    });
  });
});
express = require('express');
app = express();
bodyParser = require('body-parser');
app.use(bodyParser.json());
router = express.Router();
router.all('/job', function(req, res){
  var obj;
  obj = req.body;
  if (_.isArray(obj)) {
    if (_.empty(obj)) {
      return res.status(500), res.send('Array is empty');
    }
    createBatch(obj, function(err){
      var i$, ref$, len$, type, ref1$;
      if (!err) {
        for (i$ = 0, len$ = (ref$ = _.unique(_.map(fn$, obj))).length; i$ < len$; ++i$) {
          type = ref$[i$];
          if ((ref1$ = queues[type]) != null) {
            ref1$.processPendingJobs();
          }
        }
      }
      res.status(err ? 500 : 200);
      res.send(err);
      function fn$(it){
        return it.type;
      }
    });
  } else {
    createJob(obj, function(err){
      res.status(err ? 500 : 200);
      res.send(err);
    });
  }
});
router.all('/update-config', function(req, res){
  updateConfig();
  res.send('');
});
app.use('/', router);
app.listen(args.port);
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}