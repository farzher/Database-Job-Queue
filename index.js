// Generated by LiveScript 1.2.0
var redis, _, client, redisInts, getTimestamp, Task, Process, q;
redis = require('redis');
_ = require('prelude-ls-extended');
client = redis.createClient(16365, 'pub-redis-16365.us-east-1-3.1.ec2.garantiadata.com');
redisInts = ['attempts', 'failedAttempts', 'priority', 'backoff', 'delay', 'insertedAt'];
getTimestamp = function(){
  return Math.floor(Date.now() / 1000);
};
Task = (function(){
  Task.displayName = 'Task';
  var prototype = Task.prototype, constructor = Task;
  function Task(id, redisOptions){
    this.id = id;
    this.redisOptions = redisOptions != null
      ? redisOptions
      : {};
    this.data = this.redisOptions.data;
    this.type = this.redisOptions.type;
    this.process = q.processes[this.type];
    this.options = import$(import$({}, this.process.options), this.redisOptions);
  }
  prototype.toRedisHash = function(){
    var result, e;
    result = import$({}, this.redisOptions);
    result.data = (function(){
      try {
        return JSON.stringify(this.data);
      } catch (e$) {
        e = e$;
        return '{}';
      }
    }.call(this));
    return result;
  };
  prototype.setState = function(state, next){
    var m, score, this$ = this;
    next == null && (next = function(){});
    m = client.multi();
    if (state === 'pending' && this.state == null) {
      if (this.options.delay > 0) {
        state = 'delayed';
      }
    }
    if (state === 'failed') {
      this.redisOptions.failedAttempts = (this.redisOptions.failedAttempts || 0) + 1;
      m.hset(q.key("task:" + this.id), 'failedAttempts', this.redisOptions.failedAttempts);
      if (this.redisOptions.failedAttempts < this.options.attempts) {
        state = 'pending';
      }
      if (state === 'pending' && this.options.backoff > 0) {
        state = 'delayed';
      }
    }
    score = state === 'delayed'
      ? this.redisOptions.failedAttempts != null
        ? getTimestamp() + this.options.backoff
        : getTimestamp() + this.options.delay
      : this.options.priority;
    if (this.state != null) {
      m.zrem(q.key("state:" + this.state), this.id);
      m.zrem(q.key("state:" + this.state + ":type:" + this.type), this.id);
    }
    m.zadd(q.key("state:" + state), score, this.id);
    m.zadd(q.key("state:" + state + ":type:" + this.type), score, this.id);
    return m.exec(function(err, res){
      this$.state = state;
      return next(err);
    });
  };
  prototype.save = function(next){
    var this$ = this;
    this.redisOptions.insertedAt = getTimestamp();
    return client.incr(q.key('taskIncrementId'), function(err, id){
      var m;
      this$.id = id;
      if (err) {
        return next(err);
      }
      m = client.multi();
      m.hmset(q.key("task:" + this$.id), this$.toRedisHash());
      m.zadd(q.key("type:" + this$.type), this$.options.priority, this$.id);
      return m.exec(function(err, res){
        if (err) {
          return next(err);
        }
        return this$.setState('pending', function(err){
          next(err);
          if (err) {
            return;
          }
          return this$.process.pickupPendingTasks();
        });
      });
    });
  };
  prototype.execute = function(){
    var this$ = this;
    return this.setState('processing', function(err){
      return this$.process.execute(this$);
    });
  };
  prototype.done = function(err){
    var this$ = this;
    err == null && (err = null);
    this.process.processingCount -= 1;
    if (!err) {
      return this.setState('successful', function(err){
        return this$.process.pickupPendingTasks();
      });
    } else {
      return this.setState('failed', function(err){
        return this$.process.pickupPendingTasks();
      });
    }
  };
  return Task;
}());
Process = (function(){
  Process.displayName = 'Process';
  var prototype = Process.prototype, constructor = Process;
  function Process(type, options, cb){
    this.type = type;
    this.options = options != null ? options : null;
    this.cb = cb != null ? cb : null;
    this.processingCount = 0;
    this.pickupPendingTasks();
  }
  prototype.pickupPendingTasks = function(){
    var m, this$ = this;
    if (this.options.limit > 0) {
      if (this.processingCount >= this.options.limit) {
        return;
      }
    }
    this.processingCount += 1;
    m = client.multi();
    m.zrange(q.key("state:pending:type:" + this.type), 0, 0);
    m.zremrangebyrank(q.key("state:pending:type:" + this.type), 0, 0);
    return m.exec(function(err, res){
      var id;
      id = res[0][0];
      if (!id) {
        return this$.processingCount -= 1;
      }
      return q.getTask(id, function(err, task){
        task.state = 'pending';
        task.execute();
        return this$.pickupPendingTasks();
      });
    });
  };
  prototype.execute = function(task){
    return this.cb(task);
  };
  return Process;
}());
q = (exports.namespace = 'q', exports.key = function(it){
  return q.namespace + ":" + it;
}, exports.processes = {}, exports.process = function(type, options, cb){
  options == null && (options = null);
  cb == null && (cb = null);
  if (cb == null) {
    cb = options;
  }
  if (!_.isType('Object', options)) {
    options = {};
  }
  options = import$({
    priority: 0,
    limit: 1,
    attempts: 1,
    backoff: 0,
    delay: 0
  }, options);
  return q.processes[type] = new Process(type, options, cb);
}, exports.create = function(type, data, redisOptions, next){
  var task;
  data == null && (data = {});
  redisOptions == null && (redisOptions = {});
  next == null && (next = function(){});
  task = new Task(null, (redisOptions.type = type, redisOptions.data = data, redisOptions));
  task.save(next);
  return task;
}, exports.listen = function(port){
  var express, app, bodyParser, router;
  express = require('express');
  app = express();
  bodyParser = require('body-parser');
  app.use(bodyParser.json());
  router = express.Router();
  router.post('/task', function(req, res){
    var obj;
    obj = req.body;
    return q.create(obj.type, obj.data, obj.options, function(err){
      res.status(err ? 500 : 200);
      return res.send();
    });
  });
  app.use('/', router);
  app.listen(port);
  return {
    app: app,
    router: router
  };
}, exports.getTask = function(id, next){
  return client.hgetall(q.key("task:" + id), function(err, res){
    var e, i$, ref$, len$, name;
    if (err) {
      return next(err);
    }
    if (!res) {
      return next(404);
    }
    res.data = (function(){
      try {
        return JSON.parse(res.data);
      } catch (e$) {
        e = e$;
        return {};
      }
    }());
    for (i$ = 0, len$ = (ref$ = redisInts).length; i$ < len$; ++i$) {
      name = ref$[i$];
      if (res[name] != null) {
        res[name] = parseInt(res[name]);
      }
    }
    return next(null, new Task(id, res));
  });
}, exports);
client.setnx(q.key('taskIncrementId'), 0);
setInterval(function(){
  var timestamp, m, this$ = this;
  timestamp = getTimestamp();
  m = client.multi();
  m.zrangebyscore(q.key('state:delayed'), 0, timestamp);
  m.zremrangebyscore(q.key('state:delayed'), 0, timestamp);
  return m.exec(function(err, res){
    var ids, i$, len$, id, results$ = [];
    ids = res[0];
    for (i$ = 0, len$ = ids.length; i$ < len$; ++i$) {
      id = ids[i$];
      results$.push(q.getTask(id, fn$));
    }
    return results$;
    function fn$(err, task){
      task.state = 'delayed';
      return task.setState('pending', function(err){
        return task.process.pickupPendingTasks();
      });
    }
  });
}, 5000);
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}