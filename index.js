// Generated by LiveScript 1.2.0
var redis, _, client, obj2redis, redis2obj, getTimestamp, Task, Process, q;
redis = require('redis');
_ = require('prelude-ls-extended');
client = redis.createClient(16365, 'pub-redis-16365.us-east-1-3.1.ec2.garantiadata.com');
obj2redis = function(it){
  var data, e;
  data = (function(){
    try {
      return JSON.stringify(it.data);
    } catch (e$) {
      e = e$;
      return '{}';
    }
  }());
  return it.data = data, it;
};
redis2obj = function(it){
  var data, e;
  data = (function(){
    try {
      return JSON.parse(it.data);
    } catch (e$) {
      e = e$;
      return {};
    }
  }());
  if (it.attempts != null) {
    it.attempts = parseInt(it.attempts);
  }
  if (it.failedAttempts != null) {
    it.failedAttempts = parseInt(it.failedAttempts);
  }
  if (it.priority != null) {
    it.priority = parseInt(it.priority);
  }
  if (it.backoff != null) {
    it.backoff = parseInt(it.backoff);
  }
  if (it.delay != null) {
    it.delay = parseInt(it.delay);
  }
  if (it.insertedAt != null) {
    it.insertedAt = parseInt(it.insertedAt);
  }
  return it.data = data, it;
};
getTimestamp = function(){
  return Math.floor(Date.now() / 1000);
};
Task = (function(){
  Task.displayName = 'Task';
  var prototype = Task.prototype, constructor = Task;
  function Task(arg$){
    this.id = arg$.id, this.type = arg$.type, this.data = arg$.data, this.redisOptions = arg$.redisOptions;
    this.process = q.processes[this.type];
    this.options = import$({}, this.process.options);
    import$(this.options, this.redisOptions);
  }
  prototype.setState = function(state, next){
    var m, score, this$ = this;
    next == null && (next = function(){});
    m = client.multi();
    if (state === 'pending' && this.state == null) {
      if (this.options.delay > 0) {
        state = 'delayed';
      }
    }
    if (state === 'failed') {
      this.redisOptions.failedAttempts = (this.redisOptions.failedAttempts || 0) + 1;
      m.hset(q.key("task:" + this.id), 'failedAttempts', this.redisOptions.failedAttempts);
      if (this.redisOptions.failedAttempts < this.options.attempts) {
        state = 'pending';
      }
      if (state === 'pending' && this.options.backoff > 0) {
        state = 'delayed';
      }
    }
    score = state === 'delayed'
      ? this.redisOptions.failedAttempts != null
        ? getTimestamp() + this.options.backoff
        : getTimestamp() + this.options.delay
      : this.options.priority;
    if (this.state != null) {
      m.zrem(q.key("state:" + this.state), this.id);
      m.zrem(q.key("state:" + this.state + ":type:" + this.type), this.id);
    }
    m.zadd(q.key("state:" + state), score, this.id);
    m.zadd(q.key("state:" + state + ":type:" + this.type), score, this.id);
    return m.exec(function(err, res){
      this$.state = state;
      return next(err);
    });
  };
  prototype.save = function(next){
    var this$ = this;
    this.redisOptions.insertedAt = getTimestamp();
    return client.incr(q.key('taskIncrementId'), function(err, id){
      var hash, m;
      this$.id = id;
      if (err) {
        return next(err);
      }
      hash = obj2redis(import$({
        type: this$.type,
        data: this$.data
      }, this$.redisOptions));
      m = client.multi();
      m.hmset(q.key("task:" + this$.id), hash);
      m.zadd(q.key("type:" + this$.type), this$.options.priority, this$.id);
      return m.exec(function(err, res){
        if (err) {
          return next(err);
        }
        return this$.setState('pending', function(err){
          next(err);
          if (err) {
            return;
          }
          return this$.process.pickupPendingTasks();
        });
      });
    });
  };
  prototype.execute = function(){
    var this$ = this;
    return this.setState('processing', function(err){
      return this$.process.execute(this$);
    });
  };
  prototype.done = function(err){
    var this$ = this;
    err == null && (err = null);
    this.process.processingCount -= 1;
    if (!err) {
      return this.setState('successful', function(err){
        return this$.process.pickupPendingTasks();
      });
    } else {
      return this.setState('failed', function(err){
        return this$.process.pickupPendingTasks();
      });
    }
  };
  return Task;
}());
Process = (function(){
  Process.displayName = 'Process';
  var prototype = Process.prototype, constructor = Process;
  function Process(type, options, cb){
    this.type = type;
    this.options = options != null ? options : null;
    this.cb = cb != null ? cb : null;
    this.processingCount = 0;
    this.pickupPendingTasks();
  }
  prototype.pickupPendingTasks = function(){
    var m, this$ = this;
    if (this.options.limit > 0) {
      if (this.processingCount >= this.options.limit) {
        return;
      }
    }
    this.processingCount += 1;
    m = client.multi();
    m.zrange(q.key("state:pending:type:" + this.type), 0, 0);
    m.zremrangebyrank(q.key("state:pending:type:" + this.type), 0, 0);
    return m.exec(function(err, res){
      var id;
      id = res[0][0];
      if (!id) {
        return this$.processingCount -= 1;
      }
      return client.hgetall(q.key("task:" + id), function(err, res){
        var obj, data, redisOptions, task;
        obj = redis2obj(res);
        data = obj.data;
        delete obj.data;
        redisOptions = obj;
        task = new Task({
          id: id,
          type: this$.type,
          data: data,
          redisOptions: redisOptions
        });
        task.state = 'pending';
        task.execute();
        return this$.pickupPendingTasks();
      });
    });
  };
  prototype.execute = function(task){
    return this.cb(task);
  };
  return Process;
}());
q = (exports.namespace = 'q', exports.key = function(it){
  return q.namespace + ":" + it;
}, exports.processes = {}, exports.process = function(type, options, cb){
  options == null && (options = null);
  cb == null && (cb = null);
  if (cb == null) {
    cb = options;
  }
  if (!_.isType('Object', options)) {
    options = {};
  }
  options = import$({
    priority: 0,
    limit: 1,
    attempts: 1,
    backoff: 0,
    delay: 0
  }, options);
  return q.processes[type] = new Process(type, options, cb);
}, exports.create = function(type, data, redisOptions, next){
  var task;
  data == null && (data = {});
  redisOptions == null && (redisOptions = {});
  next == null && (next = function(){});
  task = new Task({
    type: type,
    data: data,
    redisOptions: redisOptions
  });
  task.save(next);
  return task;
}, exports.listen = function(port){
  var express, app, bodyParser, router;
  express = require('express');
  app = express();
  bodyParser = require('body-parser');
  app.use(bodyParser.json());
  router = express.Router();
  router.post('/task', function(req, res){
    var obj;
    obj = req.body;
    return q.create(obj.type, obj.data, obj.options, function(err){
      res.status(err ? 500 : 200);
      return res.send();
    });
  });
  app.use('/', router);
  app.listen(port);
  return {
    app: app,
    router: router
  };
}, exports);
client.setnx(q.key('taskIncrementId'), 0);
setInterval(function(){
  var timestamp, m, this$ = this;
  timestamp = getTimestamp();
  m = client.multi();
  m.zrangebyscore(q.key('state:delayed'), 0, timestamp);
  m.zremrangebyscore(q.key('state:delayed'), 0, timestamp);
  return m.exec(function(err, res){
    var ids, m, i$, len$, id;
    ids = res[0];
    if (!_.empty(ids)) {
      m = client.multi();
      for (i$ = 0, len$ = ids.length; i$ < len$; ++i$) {
        id = ids[i$];
        m.hgetall(q.key("task:" + id));
      }
      return m.exec(function(err, results){
        var i$, len$, i, res, id, obj, data, redisOptions, task, results$ = [];
        for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
          i = i$;
          res = results[i$];
          id = ids[i];
          obj = redis2obj(res);
          data = obj.data;
          delete obj.data;
          redisOptions = obj;
          task = new Task({
            id: id,
            type: redisOptions.type,
            data: data,
            redisOptions: redisOptions
          });
          task.state = 'delayed';
          results$.push(task.setState('pending', fn$));
        }
        return results$;
        function fn$(err){
          return task.process.pickupPendingTasks();
        }
      });
    }
  });
}, 5000);
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}