// Generated by LiveScript 1.2.0
var mongodb, MongoClient, db, collection, config, _, async, request, Job, Queue, args, queues, defaultOptions, createJob, createBatch, express, app, bodyParser, router;
mongodb = require('mongodb');
MongoClient = mongodb.MongoClient;
db = collection = config = null;
_ = require('prelude-ls-extended');
async = require('async');
request = require('request');
Job = (function(){
  Job.displayName = 'Job';
  var prototype = Job.prototype, constructor = Job;
  function Job(model){
    this.model = model != null
      ? model
      : {};
    this.data = this.model.data;
    this.queue = queues[this.model.type];
  }
  prototype.option = function(it){
    var that;
    switch (false) {
    case (that = this.model[it]) == null:
      return that;
    default:
      return this.queue.options[it];
    }
  };
  prototype.update = function(data, next){
    import$(this.model, data);
    collection.update({
      _id: this.model._id
    }, {
      $set: data
    }, next);
  };
  prototype.setState = function(state, next){
    var updateData, this$ = this;
    next == null && (next = function(){});
    updateData = {};
    if (state === 'failed') {
      updateData.failedAttempts = (this.option('failedAttempts') || 0) + 1;
      if (updateData.failedAttempts < this.option('attempts')) {
        state = 'pending';
      }
      if (state === 'pending' && this.option('backoff') > 0) {
        state = 'delayed';
        updateData.delayTil = Date.now() + this.option('backoff') * 1000;
      }
    }
    if (state === 'killed') {
      state = 'failed';
    }
    this.update((updateData.state = state, updateData), function(err){
      next(err);
    });
  };
  prototype.done = function(err){
    var this$ = this;
    err == null && (err = null);
    this.queue.processingCount -= 1;
    if (err == null) {
      this.setState('successful', function(err){
        this$.queue.processPendingJobs();
      });
    } else {
      this.setState('failed', function(err){
        this$.queue.processPendingJobs();
      });
    }
  };
  prototype.retry = function(next){
    next == null && (next = function(){});
    this.setState('pending', next);
  };
  prototype.kill = function(next){
    next == null && (next = function(){});
    this.setState('killed', next);
  };
  prototype.log = function(message, next){
    next == null && (next = function(){});
    collection.update({
      _id: this.model._id
    }, {
      $push: {
        logs: message
      }
    }, next);
  };
  return Job;
}());
Job.create = function(model, next){
  var delay, ref$, ref1$, duration, ref2$, ref3$;
  model.state = 'pending';
  delay = model.delay || ((ref$ = queues[model.type]) != null ? (ref1$ = ref$.options) != null ? ref1$.delay : void 8 : void 8) || 0;
  if (delay > 0) {
    model.state = 'delayed';
    model.delayTil = Date.now() + delay * 1000;
  }
  duration = model.duration || ((ref2$ = queues[model.type]) != null ? (ref3$ = ref2$.options) != null ? ref3$.duration : void 8 : void 8) || 0;
  model.resetAt = Date.now() + duration * 1000;
  collection.insert(model, function(err, docs){
    var job;
    console.log('inserted new job:', model);
    job = new Job(docs[0]);
    next(err, job);
  });
};
Job.getPending = function(type, next){
  collection.findAndModify({
    type: type,
    state: 'pending'
  }, [['priority', 'asc']], {
    $set: {
      state: 'processing'
    }
  }, {
    'new': true
  }, function(err, doc){
    next(err, doc ? new Job(doc) : null);
  });
};
Queue = (function(){
  Queue.displayName = 'Queue';
  var prototype = Queue.prototype, constructor = Queue;
  function Queue(type, _options){
    this.type = type;
    this._options = _options != null
      ? _options
      : {};
    this.options = import$(import$({}, defaultOptions), this._options);
    this.processingCount = 0;
    this.processPendingJobs();
  }
  prototype.processPendingJobs = function(){
    var this$ = this;
    console.log('processingCount:', this.processingCount);
    if (this.options.limit >= 0) {
      if (this.processingCount >= this.options.limit) {
        return;
      }
    }
    this.processingCount += 1;
    Job.getPending(this.type, function(err, job){
      console.log('found job:', job != null);
      if (!job) {
        return this$.processingCount -= 1;
      }
      this$.process(job);
      this$.processPendingJobs();
    });
  };
  prototype.process = function(job){
    console.log('pushing job to:', this.options.endpoint);
    request.post(this.options.endpoint, {
      json: job.model
    }, function(err, res, body){
      var message;
      if (err) {
        return job.done(err);
      }
      if (res.statusCode === 200) {
        job.done(null, body);
      } else if (res.statusCode === 202) {
        job.retry();
      } else if (res.statusCode === 403) {
        job.kill();
      } else {
        message = res.statusCode + (body ? ": " + body : '');
        job.done(message);
      }
    });
  };
  return Queue;
}());
args = {
  connect: 'mongodb://farzher:testing@kahana.mongohq.com:10017/queue',
  port: 1337,
  promoteInterval: 5000,
  endpoint: 'http://httpbin.org/code/500'
};
queues = {};
defaultOptions = {
  priority: 0,
  limit: 1,
  attempts: 1,
  backoff: 0,
  delay: 0,
  duration: 60 * 60,
  endpoint: args.endpoint
};
MongoClient.connect(args.connect, function(err, db){
  console.log('Connected');
  db = db;
  collection = db.collection('jobs');
  db.collection('config').findOne(function(err, dbConfig){
    var k, ref$, v;
    config = dbConfig;
    if (config == null) {
      config = {
        queues: {
          'default': {}
        }
      };
      db.collection('config').insert(config, function(err, docs){});
    }
    for (k in ref$ = config.queues) {
      v = ref$[k];
      queues[k] = new Queue(k, v);
    }
    collection.ensureIndex({
      type: 1
    }, function(){
      collection.ensureIndex({
        state: 1
      }, function(){
        collection.ensureIndex({
          priority: 1
        }, function(){
          collection.ensureIndex({
            delayTil: 1
          }, function(){
            collection.ensureIndex({
              resetAt: 1
            }, function(){
              setInterval(function(){
                collection.find({
                  state: 'delayed',
                  delayTil: {
                    $lte: Date.now()
                  }
                }, {
                  _id: true,
                  type: true
                }).toArray(function(err, delayedDocs){
                  collection.find({
                    state: 'processing',
                    resetAt: {
                      $lte: Date.now()
                    }
                  }, {
                    _id: true,
                    type: true
                  }).toArray(function(err, hangingDocs){
                    var docs, _ids;
                    docs = delayedDocs.concat(hangingDocs);
                    if (_.empty(docs)) {
                      return;
                    }
                    _ids = _.map(function(it){
                      return it._id;
                    }, docs);
                    collection.update({
                      _id: {
                        $in: _ids
                      }
                    }, {
                      $set: {
                        state: 'pending'
                      }
                    }, {
                      multi: true
                    }, function(err){
                      var i$, ref$, len$, type, ref1$;
                      for (i$ = 0, len$ = (ref$ = _.unique(_.map(fn$, docs))).length; i$ < len$; ++i$) {
                        type = ref$[i$];
                        if ((ref1$ = queues[type]) != null) {
                          ref1$.processPendingJobs();
                        }
                      }
                      function fn$(it){
                        return it.type;
                      }
                    });
                  });
                });
              }, args.promoteInterval);
            });
          });
        });
      });
    });
  });
});
createJob = function(obj, next){
  next == null && (next = function(){});
  Job.create(obj, function(err, job){
    if (job.model.state === 'pending') {
      job.queue.processPendingJobs();
    }
    next(err);
  });
};
createBatch = function(arr, next){
  next == null && (next = function(){});
  async.each(arr, function(){
    Job.create.apply(this, arguments);
  }, next);
};
express = require('express');
app = express();
bodyParser = require('body-parser');
app.use(bodyParser.json());
router = express.Router();
router.post('/job', function(req, res){
  var obj;
  obj = req.body;
  if (_.isArray(obj)) {
    if (_.empty(obj)) {
      return res.status(500), res.send('Array is empty');
    }
    createBatch(obj, function(err){
      var i$, ref$, len$, type, ref1$;
      if (!err) {
        for (i$ = 0, len$ = (ref$ = _.unique(_.map(fn$, obj))).length; i$ < len$; ++i$) {
          type = ref$[i$];
          if ((ref1$ = queues[type]) != null) {
            ref1$.processPendingJobs();
          }
        }
      }
      res.status(err ? 500 : 200);
      res.send(err);
      function fn$(it){
        return it.type;
      }
    });
  } else {
    createJob(obj, function(err){
      res.status(err ? 500 : 200);
      res.send(err);
    });
  }
});
app.use('/', router);
app.listen(args.port);
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}